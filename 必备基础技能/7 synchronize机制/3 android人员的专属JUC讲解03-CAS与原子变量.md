  1.CAS效率分析与原子变量

  2.原子引用下的ABA问题

  3.原子更新器与累加器

  4.LongAddr原理

  5.unsafe实现原子数组



## 为什么无锁状态下的运行效率会高？

- 单纯的CAS理论：
  - 单纯的CAS理论只是为了完成一次比较确认值的同步
  - 与代码块的同步并没有关系

- CAS理论应用下的锁实现原理：
  - 利用volatile变量与CAS理论保证在一定时间段内变量结果的一致性
  - 同步对于线程进行阻塞

- CAS无锁状态下与synchronize有锁状态下的本质区别

  - 无锁情况下，即使重试失败，线程始终在高速运行，没有停歇，而synchronized会让线程在没有获得锁的时候，发生上下文切换，进入阻塞

  - 比喻：高速上飙车，当前自己开200码，正常的高速运行，但是一旦发生上下文切换，需要减速停车，换路，在加速，代价相对高昂

  - 无锁状态下，因为线程需要保持运行，则需要额外CPU的支持，CPU在这里就是高速公路，没路我们走不下去，一开始没有加锁，不会有阻塞，但是没有时间片，会导致上下文切换，所以CAS需要有多核CPU对于其进行支撑，单核体系下效率不一定



## CAS效率分析

结合CAS与volatile实现无锁并发情况的适用场景：

 多核CPU场景下，且线程数少

CAS基于乐观锁思想，最乐观结果，不怕别的线程来修改共享变量，改了也没事，我在重试

synchronize基于悲观锁思想：最悲观结果，得放着其他线程来修改共享变量，我上锁，你们都别改，我改了解开你们才有机会



CAS体现的是无锁并发，无阻塞并发

 因为没有synchronized，线程不会陷入阻塞，这是效率提升的因素之一

 如果竞争几率，重试必然发生频繁，效率会下降



最好结果为线程数不超过CPU核心数

## 线程的上下文切换

本质：CPU切换前把当前任务的状态保存下来，以便下次切换回这个任务时可以再次加载这个任务的状态，然后加载下一任务的状态并执行。任务的状态保存及再加载, 这段过程就叫做上下文切换。



每个线程都有一个程序计数器（记录要执行的下一条指令），一组寄存器（保存当前线程的工作变量），堆栈（记录执行历史，其中每一帧保存了一个已经调用但未返回的过程）。



寄存器 是 CPU 内部的数量较少但是速度很快的内存（与之对应的是 CPU 外部相对较慢的 RAM 主内存）。寄存器通过对常用值（通常是运算的中间值）的快速访问来提高计算机程序运行的速度。



程序计数器是一个专用的寄存器，用于表明指令序列中 CPU 正在执行的位置，存的值为正在执行的指令的位置或者下一个将要被执行的指令的位置。



上下文切换会导致额外的开销，常常表现为高并发执行时速度会慢串行，因此减少上下文切换次数便可以提高多线程程序的运行效率。



直接消耗：指的是CPU寄存器需要保存和加载, 系统调度器的代码需要执行, TLB实例需要重新加载, CPU 的pipeline需要刷掉

间接消耗：指的是多核的cache之间得共享数据, 间接消耗对于程序的影响要看线程工作区操作数据的大小



## J.U.C并发包



什么是JSR：

JSR，全称 Java Specification Requests， 即Java规范提案， 主要是用于向JCP(Java Community Process)提出新增标准化技术规范的正式请求。每次JAVA版本更新都会有对应的JSR更新，比如在Java 8版本中，其新特性Lambda表达式对应的是JSR 335，新的日期和时间API对应的是JSR 310。



什么是JSR 166：

JSR 166，它是一个关于Java并发编程的规范提案，在JDK中，该规范由java.util.concurrent包实现，是在JDK 5.0的时候被引入的；



另外JDK6引入Deques、Navigable collections，对应的是JSR 166x，JDK7引入fork-join框架，用于并行执行任务，对应的是JSR 166y。



什么是J.U.C：

即java.util.concurrent的缩写，该包参考自EDU.oswego.cs.dl.util.concurrent，是JSR 166标准规范的一个实现；



##  并发包内容

- Executor框架（线程池、 Callable 、Future）

- AbstractQueuedSynchronizer （AQS框架）

- Locks & Condition（锁和条件变量）

- Synchronizers（同步器）

- Atomic Variables（原子变量）

- BlockingQueue（阻塞队列）

- Concurrent Collections（并发容器）

- Fork/Join并行计算框架

- TimeUnit枚举

## Atomic Variables（原子变量）

本质上是一组工具，位置在atomic包下

 实际上祖师爷已经帮我们把CAS的相关实现全部搞定，并且封装了

 处理并发安全问题上：

 1.单个原子处理

 2.块处理

 本质上分类两类，

 1.保证基本数据类型的原子性（AtomicInteger...）

 2.保证引用类型的原子性（AtomicReference）

## 原子引用与ABA问题

ABA问题：

 在多线程对于原子变量操作时，会发生将数据变更回去的现象，CAS在判断时会造成概念上的认知错误，但是实际上对业务结果是不变的

 但是实际业务运用过程中可能会需要知道整个运行过程值是否改变

 通过AtomicStampedReference 追溯版本号

 通过AtomicMarkableReference 得到是否更改结果

## 不同场景下的原子变量操作方案

AtomicReference本质上是对于引用类型的地址

但是我们常规使用中，更多的业务是要判定内部数据是否一致

原子数组：

 保证数组内元素的线程安全

字段：

 字段更新器  AtomicReferenceFieldUpdater

累加业务：

 原子累加器

## LongAdder与Atomic比较

性能提升的原因很简单，就是有竞争时，设置多个累加单元，然后最后结果汇总，他这样的累加操作不同的cell变量，因此减少了Cas重试失败，从而提高性能



## LongAdder原理分析

性能提升的原因很简单，就是有竞争时，设置多个累加单元，然后最后结果汇总，他这样的累加操作不同的cell变量，因此减少了Cas重试失败，从而提高性能

```java
transient volatile Cell[] cells；//累加单元
transient volatile long base; // 基础值
transient volatile int cellsBase；//锁标志
```

### LongAdder伪共享原理与缓存行

什么是伪共享？

 CPU高度缓冲器的存储体系下，一个基本的缓存单位叫做缓存行，一个缓存行的大小为64byte,

 数组是一块连续的空间，因为副本数据的原因，数组加载到缓存当中，数据超过64字节会占用多行,若小于64字节则占用一行



## 总结

对于并发处理，从业务角度我们看做为两块：

 1.原子变量操作

 2.业务代码块的并发



并发手段现在接触的是两种：

 1.加锁并发：synchronize（悲观体现）

 2.无锁并发：CAS应用实现（乐观体现）