# 技术点：

CPU、高速缓冲区、主内存协调机制

线程间变量与同步

java对象内存分布详解。为什么Object有9个方法5个都是跟并发有关

synchronized锁升级过程(自旋锁、偏向锁、轻量级锁、重量级锁)

# 并发关联的两个类（线程Thread、锁synchronized）

##  Thread

 **进程和线程的区别与联系**

进程是正在运行的程序的实例，进程是线程的容器

 线程是操作系统能够进行运算调度的最小单位

一个进程可以有很多线程，每条线程并行执行不同的任务

**Java内存模型**

![JMM](https://img2022.cnblogs.com/blog/1015893/202202/1015893-20220212180809131-1465534279.png)

高速缓冲区解决问题：

​	 内存读写相对于CPU的运行速度慢很多，需要高速缓冲区协助与内存进行交互，提高CPU的利用率

```
由于计算机的存储设备与处理器的运算速度有几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。
```

**JVM与Android的关系**



![](https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fupload-images.jianshu.io%2Fupload_images%2F9000209-10390b8033ee3a45.png&refer=http%3A%2F%2Fupload-images.jianshu.io&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1665559110&t=cbe6ae0c18c76dbcf654016f806ca81f)

执行引擎：执行Class中的字节码

本地接口：做Native的运行

本地方法库：包含系统的so

**主内存与工作内存**

Java内存模型规定了所有的变量都存储在主内存（Main Memory）中。每条线程还有自己的工作内存，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。

**线程的生命周期** ![](https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg2020.cnblogs.com%2Fblog%2F1965282%2F202005%2F1965282-20200506161732172-1519590330.png&refer=http%3A%2F%2Fimg2020.cnblogs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1665560083&t=b7bc2ae2d735cdf6e3e7b487d1b6f8ab)

- 新建（New）：创建后尚未启动的线程处于这种状态。

- 运行（Runable）：Runable包括了操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待着CPU为它分配执行时间。 

- 无限期等待（Waiting）：处于这种状态的线程不会被分配CPU执行时间，它们要等待被其他线程显式地唤醒。以下方法会让线程陷入无限期的等待状态： 
  - 没有设置Timeout参数的Object.wait（）方法。
  - 没有设置Timeout参数的Thread.join（）方法。
  - LockSupport.park（）方法。
-  限期等待（Timed Waiting）：处于这种状态的线程也不会被分配CPU执行时间，不过无须等待被其他线程显式地唤醒，在一定时间之后它们会由系统自动唤醒。以下方法会让线程进入限期等待状态： 
  - Thread.sleep（）方法。
  - 设置了Timeout参数的Object.wait（）方法。 
  - 设置了Timeout参数的Thread.join（）方法。 
  - LockSupport.parkNanos（）方法。 
  - LockSupport.parkUntil（）方法。

- 阻塞（Blocked）：线程被阻塞了，“阻塞状态”与“等待状态”的区别是：“阻塞状态”在等待着获取到一个排他锁，这个事件将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。 

- 结束（Terminated）：已终止线程的线程状态，线程已经结束执行。

**Java Thread的本质**

- new Thread() 设置线程优先级等并没有什么实质性的操作

- start()才是真正开启线程的方法

```
start方法是一个同步方法，首先会检查状态，如果状态不为0(NEW),抛异常，所以如果多次调用同一个线程的start方法时，只有一次能够成功，其他情况下都会抛异常.然后将该线程对象加入到threadGroup中，threadGroup用一个数组来记录了这个组有哪些线程,紧接着调用本地方法start0,

如果调用中有异常，会从threadGroup中移除该thread对象.接下来看下start0,其实现在jvm中，对应JVM_StartThread方法,jvm在java调用start方法时， 

start0--->JVM_StartThread 函数

代码调用:

jvm.cpp->(os:create_thread)thread.cpp->(pthread_create)oslinux.cpp
```



