# 基础使用

- 修饰方法
  - 修饰静态方法
  - 修饰普通方法

- 修饰代码块
  -  锁this
  - 锁 Object object = new Object()  锁object 

# 互斥同步（悲观）

##synchronized

在Java中，最基本的互斥同步手段就是synchronized关键字，

 synchronized关键字经过编译之后，会在同步块的前后分别形成**monitorenter和monitorexit**这两个字节码指令

```
  0000: monitor-enter v1
  0001: const/16 v0, #int 100 // #0064
  0003: monitor-exit v1
  0004: return-void
```

```
代码：
share/vm/interpreter/interpreterRuntime.cpp 

```

这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象。

如果Java程序中的synchronized明确指定了对象参数，那就是这个对象的reference；

如果没有明确指定，那就根据synchronized修饰的是实例方法还是类方法，去取对应的对象实例或Class对象来作为锁对象。

**为什么Java9个方法5个和并发有关**

把实现放在内存中使用，

**synchronized原理**

锁实现原理之前先了解一下Java的对象头和Monitor，在JVM中，对象是分成**三部分**存在的：

> 对象头 
>
> 实例数据 
>
> 对其填充

![](https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg-blog.csdnimg.cn%2F20210205192652881.png&refer=http%3A%2F%2Fimg-blog.csdnimg.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1665616344&t=8604bb1935f9451658a7ad4e8cc307a7)

**Java的对象头**:

**实例数据:**存放类的属性数据信息，包括父类的属性信息，如果是数组的实例部分还包括数组的长度，这部分内存按4字节对齐；对其填充不是必须部分，由于虚拟机要求对象起始地址必须是8字节的整数倍，

**对齐填充**仅仅是为了使字节对齐。

**对象头**是我们需要关注的重点，它是synchronized实现锁的基础，因为synchronized申请锁、上锁、释放锁都与对象头有关。

​	对象头主要结构是由**Mark Word** 和 **Class Metadata Address** 组成，其中Mark Word存储对象的hashCode、锁信息或分代年龄或GC标志等信息，Class Metadata Address是类型指针指向对象的类元数据，JVM通过该指针确定该对象是哪个类的实例。

**Monitor:**

每一个锁都对应一个monitor对象，在HotSpot虚拟机中它是由ObjectMonitor实现的（C++实现）。每个对象都存在着一个monitor与之关联，对象与其monitor之间的关系有存在多种实现方式，如monitor可以与对象一起创建销毁或当线程试图获取对象锁时自动生成，但当一个monitor被某个线程持有后，它便处于锁定状态。

    _header       = NULL;
    _count        = 0;  //锁计数器
    _waiters      = 0,
    _recursions   = 0;
    _object       = NULL;
    _owner        = NULL;
    _WaitSet      = NULL; //处于wait状态的线程，会被加入到_WaitSet
    _WaitSetLock  = 0 ;
    _Responsible  = NULL ;
    _succ         = NULL ;
    _cxq          = NULL ;
    FreeNext      = NULL ;
    _EntryList    = NULL ; //处于等待锁block状态的线程，会被加入到该列表
    _SpinFreq     = 0 ;
    _SpinClock    = 0 ;
    OwnerIsThread = 0 ;
##### 1.1.3 ObjectMonitor 工作机制

  ObjectMonitor中有两个队列

> **_WaitSet **     等待锁的线程集合
>
> **_EntryList**，进入锁范围的线程集合

##### 1.1.4  监视器工作流程

1. 用来保存ObjectWaiter对象列表(每个等待锁的线程都会被封装ObjectWaiter对象)，
2. owner指向持有ObjectMonitor对象的线程，当多个线程同时访问一段同步代码时， 首先会进入**_EntryList 集合**
3. 当线程获取到对象的monitor 后进入 _Owner 区域并把monitor中的owner变量设置为当前线程同时monitor中的计数器count加1，
4. 若线程调用 wait() 方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入 WaitSe t集合中等待被唤醒。
5. 若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor(锁)。

>   monitor对象存在于每**个Java对象的对象头**中(存储的指针的指向)，

**Java对象头无锁状态**

![](https://img-blog.csdnimg.cn/img_convert/62321275d27c4b099fdb87e1b73419e4.png)

Java锁状态标记

![](https://img-blog.csdnimg.cn/img_convert/e05394f5d671a8ce2fc87cfa3a51d632.png)

![](https://img-blog.csdnimg.cn/img_convert/f2824d5fdcf5487772287bb25f078205.png)

两张图对照着看，当锁住的时候hashcode会缓存起来，此时25个存储hashcode的部分将会存储，各种锁的信息





##### 1.2.4 偏向锁

一句话总结它的作用：减少统一线程获取锁的代价。在大多数情况下，锁不存在多线程竞争，总是由同一线程多次获得，那么此时就是偏向锁。

核心思想：

​		如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word的结构也就变为偏向锁结构，当该线程再次请求锁时，无需再做任何同步操作，即获取锁的过程只需要检查Mark Word的锁标记位为偏向锁以及当前线程ID等于Mark Word的ThreadID即可，这样就省去了大量有关锁申请的操作。

**过程:**  先说无锁—>偏向锁。锁的标志位都为01。
		当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要花费CAS操作来加锁和解锁，而只需简单的测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁，如果测试成功，表示线程已经获得了锁，如果测试失败，则需要再测试下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁），如果没有设置，则使用CAS竞争锁，如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。

​			要注意的是，偏向锁使用了一种**等到竞争出现**才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。**偏向锁的撤销**，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，**如果线程不处于活动状态**，则将对象头设置成无锁状态，如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。下图中的线程1演示了偏向锁初始化的流程， 

**5.1.2 轻量级锁**
轻量级锁是由偏向锁升级而来，当存在第二个线程申请同一个锁对象时，偏向锁就会立即升级为轻量级锁。注意这里的第二个线程只是申请锁，不存在两个线程同时竞争锁，可以是一前一后地交替执行同步块。

**5.1.3 重量级锁**
重	量级锁是由轻量级锁升级而来，当同一时间有多个线程竞争锁时，锁就会被升级成重量级锁，此时其申请锁带来的开销也就变大。

重量级锁一般使用场景会在追求吞吐量，同步块或者同步方法执行时间较长的场景（系统进行分配）。

**5.2 锁消除**
**消除锁是虚拟机另外一种锁的优化，这种优化更彻底，在JIT编译时，对运行上下文进行扫描，去除不可能存在竞争的锁。**

**5.3 锁粗化**
**锁粗化是虚拟机对另一种极端情况的优化处理，通过扩大锁的范围，避免反复加锁和释放锁。**

**5.4 自旋锁与自适应自旋锁**
轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。

**自旋锁：**许多情况下，共享数据的锁定状态持续时间较短，切换线程不值得，通过让线程执行循环等待锁的释放，不让出CPU。如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，这就是自旋锁的优化方式。但是它也存在缺点：如果锁被其他线程长时间占用，一直不释放CPU，会带来许多的性能开销。

**自适应自旋锁：**这种相当于是对上面自旋锁优化方式的进一步优化，它的自旋的次数不再固定，其自旋的次数由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定，这就解决了自旋锁带来的缺点。





##ReentrantLock

相比于synchronized，ReentrantLock增加了一些高级功能，

**等待可中断**：等待可中断是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情，可中断特性对处理执行时间非常长的同步块很有帮助。

**可实现公平锁**：公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。synchronized中的锁是非公平的，ReentrantLock默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。

**以及锁可以绑定多个条件**：锁绑定多个条件是指一个ReentrantLock对象可以同时绑定多个Condition对象，而在synchronized中，锁对象的wait（）和notify（）或notifyAll（）方法可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外地添加一个锁，而ReentrantLock则无须这样做，只需要多次调用newCondition（）方法即可。

# 非阻塞同步

CAS

CAS指令需要有3个操作数，分别是内存位置（在Java中可以简单理解为变量的内存地址，用V表示）、旧的预期值（用A表示）和新值（用B表示）。CAS指令执行时，当且仅当V符合旧预期值A时，处理器用新值B更新V的值，否则它就不执行更新，但是无论是否更新了V的值，都会返回V的旧值，上述的处理过程是一个原子操作。

![](https://upload-images.jianshu.io/upload_images/26777047-54804173d3a33429.gif?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)
